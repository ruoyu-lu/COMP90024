#include <iostream>
#include <fstream>
#include <map>
#include <string>
#include <sstream>
#include <iomanip>
#include <rapidjson/document.h>
#include <rapidjson/istreamwrapper.h>
#include <vector>
#include <algorithm>
#include <mpi.h>
#include <rapidjson/filereadstream.h>

struct DataTime {
    char timeKey[20];
    double sentiment_score;
    int posts_num;

    DataTime() : sentiment_score(0), posts_num(0) {
        timeKey[0] = '\0'; // 初始化为空字符串
    }

    DataTime(const std::string& key, double score, int num)
            : sentiment_score(score), posts_num(num) {
        std::strncpy(timeKey, key.c_str(), sizeof(timeKey) - 1);
        timeKey[sizeof(timeKey) - 1] = '\0';
    }
};

void process_json(const rapidjson::Document& data, int rank, int size,
                  std::vector<DataTime>& data_hour, std::vector<DataTime>& data_day) {

    std::map<std::string, double> sentiment_sum_by_hour;
    std::map<std::string, double> sentiment_sum_by_day;
    std::map<std::string, int> posts_sum_by_hour;
    std::map<std::string,int> posts_sum_by_day;

    int start = (data.MemberCount() / size) * rank;
    int end = (data.MemberCount() / size) * (rank + 1);
    for (int i = start; i < end; ++i) {

        const auto& item = data["rows"][i];

        if (!item.IsObject() || !item.HasMember("doc") || !item["doc"].IsObject()){
            continue;
        }

        const auto& doc = item["doc"];
        if (!doc.HasMember("data") || !doc["data"].IsObject()) {
            continue;
        }

        const auto& docData = doc["data"];
        if (!docData.HasMember("created_at") || !docData["created_at"].IsString()) {
            continue;
        }

        std::string created_at = docData["created_at"].GetString();
        std::tm tm = {};
        std::istringstream ss(created_at);
        ss >> std::get_time(&tm, "%Y-%m-%dT%H:%M:%S.000Z");

        if (ss.fail()) {
            std::cerr << "Failed to parse the created_at time: " << created_at << std::endl;
            continue;
        }

        double sentiment = 0; // Default to 0
        if (docData.HasMember("sentiment") && docData["sentiment"].IsNumber()) {
            sentiment = docData["sentiment"].GetDouble();
        }

        std::ostringstream os;
        os << std::put_time(&tm, "%Y-%m-%d-%H");
        std::string hour_key = os.str(); //generate hour_key

        os.str(""); // 清空ostringstream
        os << std::put_time(&tm, "%Y-%m-%d");
        std::string day_key = os.str(); //generate day_key

        sentiment_sum_by_hour[hour_key] += sentiment;
        sentiment_sum_by_day[day_key] += sentiment;
        posts_sum_by_hour[hour_key]++;
        posts_sum_by_day[day_key]++;
    }
    //push hour data to vector
    for (const auto &pair: sentiment_sum_by_hour) {
        data_hour.emplace_back(pair.first, pair.second, posts_sum_by_hour[pair.first]);
    }

    //push day data to vector
    for (const auto &pair: sentiment_sum_by_day) {
        data_day.emplace_back(pair.first, pair.second, posts_sum_by_day[pair.first]);
    }
}

int main(int argc, char** argv) {
    MPI_Init(NULL, NULL);
    int size, rank;
    MPI_Comm_size(MPI_COMM_WORLD, &size); // Get the number of processes
    MPI_Comm_rank(MPI_COMM_WORLD, &rank); // Get the rank of the process

    FILE* fp = fopen("twitter-50mb.json", "r"); // 非 Windows 平台使用 "r"

    char readBuffer[65536];
    rapidjson::FileReadStream is(fp, readBuffer, sizeof(readBuffer));

    std::string line;
    while (fgets(readBuffer, sizeof(readBuffer), fp)) {
        rapidjson::Document d;
        if (d.Parse(readBuffer).HasParseError()) {
            continue; // 解析错误，跳过
        }

        // Define a new MPI datatype for DataTime
        MPI_Datatype data_time_type;
        int blocklengths[3] = {20, 1, 1};
        MPI_Datatype types[3] = {MPI_CHAR, MPI_DOUBLE, MPI_INT};
        MPI_Aint offsets[3];
        offsets[0] = offsetof(DataTime, timeKey);
        offsets[1] = offsetof(DataTime, sentiment_score);
        offsets[2] = offsetof(DataTime, posts_num);
        MPI_Type_create_struct(3, blocklengths, offsets, types, &data_time_type);
        MPI_Type_commit(&data_time_type);

        std::string max_sentiment_hour;
        std::string max_sentiment_day;
        double max_sentiment_sum_hour = 0.0;
        double max_sentiment_sum_day = 0.0;
        std::string max_posts_hour;
        std::string max_posts_day;
        int max_posts_sum_hour = 0;
        int max_posts_sum_day = 0;

        std::vector<DataTime> data_hour;
        std::vector<DataTime> data_day;

        int num_elements_hour, num_elements_day;

        if (rank == 0) {
            process_json(d, rank, size, data_hour, data_day);

            //receive data from other ranks
            for (int i = 1; i < size; i++) {
                std::vector<DataTime> data_hour_recv;
                std::vector<DataTime> data_day_recv;

                // 假设发送方首先发送了一个整数，表示将要发送的DataTime结构体数量
                MPI_Recv(&num_elements_hour, 1, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
                MPI_Recv(&num_elements_day, 1, MPI_INT, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

                // 根据接收到的数量调整vector的大小，以准备接收数据
                data_hour_recv.resize(num_elements_hour);
                data_day_recv.resize(num_elements_day);

                MPI_Recv(data_hour_recv.data(), num_elements_hour, data_time_type, i, 0, MPI_COMM_WORLD,
                         MPI_STATUS_IGNORE);
                MPI_Recv(data_day_recv.data(), num_elements_day, data_time_type, i, 0, MPI_COMM_WORLD,
                         MPI_STATUS_IGNORE);
                data_hour.insert(data_hour.end(), data_hour_recv.begin(), data_hour_recv.end());
                data_day.insert(data_day.end(), data_day_recv.begin(), data_day_recv.end());

                //combine data from other ranks
                for (const auto &item: data_hour_recv) {
                    auto it = std::find_if(data_hour.begin(), data_hour.end(), [&item](const DataTime &a) {
                        return std::string(a.timeKey) == std::string(item.timeKey);
                    });
                    if (it != data_hour.end()) {
                        it->sentiment_score += item.sentiment_score;
                        it->posts_num += item.posts_num;
                    } else {
                        data_hour.push_back(item);
                    }
                }

                for (const auto &item: data_day_recv) {
                    auto it = std::find_if(data_day.begin(), data_day.end(), [&item](const DataTime &a) {
                        return std::string(a.timeKey) == std::string(item.timeKey);
                    });
                    if (it != data_day.end()) {
                        it->sentiment_score += item.sentiment_score;
                        it->posts_num += item.posts_num;
                    } else {
                        data_day.push_back(item);
                    }
                }
            }


            auto max_hour_sentiment_it = std::max_element(data_hour.begin(), data_hour.end(),
                                                          [](const DataTime &a, const DataTime &b) {
                                                              return a.sentiment_score < b.sentiment_score;
                                                          });

            if (max_hour_sentiment_it != data_hour.end()) {
                std::cout << "Hour with the highest sentiment score: " << max_hour_sentiment_it->timeKey
                          << " | Sentiment score: " << max_hour_sentiment_it->sentiment_score << std::endl;
            }

            auto max_day_sentiment_it = std::max_element(data_day.begin(), data_day.end(),
                                                         [](const DataTime &a, const DataTime &b) {
                                                             return a.sentiment_score < b.sentiment_score;
                                                         });

            if (max_day_sentiment_it != data_day.end()) {
                std::cout << "Day with the highest sentiment score: " << max_day_sentiment_it->timeKey
                          << " | Sentiment score: " << max_day_sentiment_it->sentiment_score << std::endl;
            }

            auto max_hour_posts_it = std::max_element(data_hour.begin(), data_hour.end(),
                                                      [](const DataTime &a, const DataTime &b) {
                                                          return a.posts_num < b.posts_num;
                                                      });
            if (max_hour_posts_it != data_hour.end()) {
                std::cout << "Hour with the most posts: " << max_hour_posts_it->timeKey
                          << " | Number of posts: " << max_hour_posts_it->posts_num << std::endl;
            }

            auto max_day_posts_it = std::max_element(data_day.begin(), data_day.end(),
                                                     [](const DataTime &a, const DataTime &b) {
                                                         return a.posts_num < b.posts_num;
                                                     });
            if (max_day_posts_it != data_day.end()) {
                std::cout << "Day with the most posts: " << max_day_posts_it->timeKey
                          << " | Number of posts: " << max_day_posts_it->posts_num << std::endl;

            }

        } else {
            process_json(d, rank, size, data_hour, data_day);

            num_elements_hour = data_hour.size();
            num_elements_day = data_day.size();

            MPI_Send(&num_elements_hour, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);
            MPI_Send(&num_elements_day, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);

            //send data to rank 0
            MPI_Send(data_hour.data(), data_hour.size(), data_time_type, 0, 0, MPI_COMM_WORLD);
            MPI_Send(data_day.data(), data_day.size(), data_time_type, 0, 0, MPI_COMM_WORLD);
        }
    }
    fclose(fp);
    MPI_Finalize();
    return 0;
}
